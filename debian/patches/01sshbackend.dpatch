#! /bin/sh /usr/share/dpatch/dpatch-run
## 01sshbackend.dpatch by  <az@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: replace sshbackend with rewritten one

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' duplicity-0.6.17~/bin/duplicity.1 duplicity-0.6.17/bin/duplicity.1
--- duplicity-0.6.17~/bin/duplicity.1	2012-02-14 15:25:47.000000000 +1000
+++ duplicity-0.6.17/bin/duplicity.1	2012-02-14 15:25:47.869271261 +1000
@@ -62,7 +62,7 @@
 .SH DESCRIPTION
 Duplicity incrementally backs up files and directory
 by encrypting tar-format volumes with GnuPG and uploading them to a
-remote (or local) file server.  Currently local, ftp, ssh/scp, rsync,
+remote (or local) file server.  Currently local, ftp, sftp/scp, rsync,
 WebDAV, WebDAVs, Google Docs, HSi and Amazon S3 backends are available.
 Because duplicity uses
 librsync, the incremental archives are space efficient and only record
@@ -611,24 +611,13 @@
 characters or other characters that are not valid in a hostname.
 .TP
 .BI "--scp-command " command
-This option only matters when using the ssh/scp backend.  The
-.I command
-will be used instead of scp to send or receive files.  The default command
-is "scp". To list and delete existing files, the sftp command is used.  See
-.BR --ssh-options
-and
-.BR --sftp-command .
+Deprecated and ignored. The sftp/scp backend does no longer use an external
+scp client program.
 
 .TP
 .BI "--sftp-command " command
-This option only matters when using the ssh/scp backend.  The
-.I command
-will be used instead of sftp for listing and deleting files.  The
-default is "sftp". File transfers are done using the sftp command. See
-.BR --ssh-options ,
-.BR --use-scp ,
-and
-.BR --scp-command .
+Deprecated and ignored. The sftp/scp backend does no longer use an external
+sftp client program.
 
 .TP
 .BI "--sign-key " key
@@ -648,25 +637,24 @@
 
 .TP
 .B --ssh-askpass
-Tells the ssh/scp backend to use FTP_PASSWORD from the environment,
+Tells the sftp/scp backend to use FTP_PASSWORD from the environment,
 or, if that is not present, to prompt the user for the remote system
-password.
+password. This password is also used for ssh keys that are passphrase-protected.
+Without this option the password is expected in the url.
 
 .TP
 .BI "--ssh-options " options
 Allows you to pass options to the ssh/scp/sftp backend.  The
 .I options
-list should be of the form "opt1=parm1 opt2=parm2" where the option string is
-quoted and the only spaces allowed are between options. The option string
-will be passed verbatim to both scp and sftp, whose command line syntax
-differs slightly: options passed with
-.BR --ssh-options
-should therefore be given in the long option format described in
-.BR ssh_config(5) ,
+list should be of the form "-oopt1=parm1 -oopt2=parm2" where the option string is
+quoted and the only spaces allowed are between options. Options must 
+be given in the long option format described in
+.BR ssh_config(5) .
+The sftp/scp backend currently supports only one ssh option, IdentityFile
 like in this example:
 .PP
 .RS
-duplicity --ssh-options="-oProtocol=2 -oIdentityFile=/my/backup/id" /home/me scp://uid@other.host/some_dir
+duplicity --ssh-options="-oIdentityFile=/my/backup/id" /home/me sftp://uid@other.host/some_dir
 .PP
 .RE
 
@@ -720,17 +708,9 @@
 
 .TP
 .BI --use-scp
-If this option is specified, then the ssh backend will use
-.I scp
-rather than
-.I sftp
-for the get and put backend operations.  The default is to use
-.I sftp
-for all operations.  With this option, duplicity will use
-.I sftp
-for list and delete operations, and
-.I scp
-for put and get operations
+If this option is specified, then the sftp/scp backend will use the
+scp protocol rather than sftp for backend operations. The default is to use
+sftp, because it does not suffer from shell quoting issues like scp.
 
 .TP
 .BI "--verbosity " level ", -v" level
@@ -843,16 +823,13 @@
 .br
 see also
 .BI "A NOTE ON UBUNTU ONE"
-.PP
-.BI "ssh protocols"
 .br
-scp://.. or sftp://.. are synonymous for
+.PP
+scp://.. or ssh://.. are synonymous with
 .br
-ssh://user[:password]@other.host[:port]/[/]some_dir
+sftp://user[:password]@other.host[:port]/[/]some_dir
 .br
 see also
-.BI "A NOTE ON SSH/SCP PROTOCOLS"
-and
 .BI "--use-scp"
 .PP
 tahoe://alias/directory
@@ -1207,29 +1184,6 @@
 .B from_address_prefix
 will distinguish between different backups.
 
-.SH A NOTE ON SSH/SCP PROTOCOLS
-Duplicity specifies two protocol names for the same protocol.  This is
-a known and user-confusing issue.  Both use the same protocol suite, namely
-.I ssh
-through its' utility routines
-.I scp
-and
-.I sftp.
-Older versions
-of duplicity used
-.I scp
-for get and put operations and
-.I sftp
-for list and
-delete operations.  The current version uses
-.I sftp
-for all four supported
-operations, unless the
-.I --use-scp
-option is used to revert to old behavior.  The change was made to
-all-sftp in order to allow the remote system to chroot the backup,
-thus providing better security.
-
 .SH A NOTE ON UBUNTU ONE
 Connecting to Ubuntu One requires that you be running duplicity inside of an X
 session so that you can be prompted for your credentials if necessary by the
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' duplicity-0.6.17~/duplicity/backends/sshbackend.py duplicity-0.6.17/duplicity/backends/sshbackend.py
--- duplicity-0.6.17~/duplicity/backends/sshbackend.py	2012-02-14 15:25:47.000000000 +1000
+++ duplicity-0.6.17/duplicity/backends/sshbackend.py	2012-02-14 15:26:13.340956845 +1000
@@ -2,6 +2,9 @@
 #
 # Copyright 2002 Ben Escoto <ben@emerose.org>
 # Copyright 2007 Kenneth Loafman <kenneth@loafman.com>
+# Copyright 2011 Alexander Zangerl <az@snafu.priv.at> 
+#
+# $Id: sshbackend.py,v 1.4 2012/02/14 05:14:03 az Exp $
 #
 # This file is part of duplicity.
 #
@@ -19,293 +22,282 @@
 # along with duplicity; if not, write to the Free Software Foundation,
 # Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 
-# The following can be redefined to use different shell commands from
-# ssh or scp or to add more arguments.  However, the replacements must
-# have the same syntax.  Also these strings will be executed by the
-# shell, so shouldn't have strange characters in them.
-
 import re
 import string
-import time
 import os
+import errno
+import sys
+import getpass
+import logging
+
+# debian squeeze's paramiko is a bit old, so we silence randompool depreciation warning
+# note also: passphrased private keys work with squeeze's paramiko only if done with DES, not AES
+import warnings                 
+with warnings.catch_warnings():
+    warnings.simplefilter("ignore")
+    import paramiko
+
 
 import duplicity.backend
 from duplicity import globals
 from duplicity import log
-from duplicity import pexpect
-from duplicity.errors import * #@UnusedWildImport
+from duplicity.errors import *
 
-class SSHBackend(duplicity.backend.Backend):
-    """This backend copies files using scp.  List not supported"""
+read_blocksize=65635            # for doing scp retrievals, where we need to read ourselves
+
+class SftpBackend(duplicity.backend.Backend):
+    """This backend accesses files using the sftp protocol, or scp when the --use-scp option is given.
+    It does not need any local client programs, but an ssh server and the sftp program must be installed on the remote 
+    side (or with --use-scp, the programs scp, ls, mkdir, rm and a POSIX-compliant shell). 
+
+    Authentication keys are requested from an ssh agent if present, then ~/.ssh/id_rsa/dsa are tried.
+    If -oIdentityFile=path is present in --ssh-options, then that file is also tried.
+    The passphrase for any of these keys is taken from the URI or FTP_PASSWORD.
+    If none of the above are available, password authentication is attempted (using the URI or FTP_PASSWORD).
+
+    Missing directories on the remote side will be created.
+
+    If --use-scp is active then all operations on the remote side require passing arguments through a shell,
+    which introduces unavoidable quoting issues: directory and file names that contain single quotes will not work.
+    This problem does not exist with sftp.
+    """
     def __init__(self, parsed_url):
-        """scpBackend initializer"""
         duplicity.backend.Backend.__init__(self, parsed_url)
 
-        # host string of form [user@]hostname
+        # host string could be [user@]hostname
         if parsed_url.username:
-            self.host_string = parsed_url.username + "@" + parsed_url.hostname
+            username=parsed_url.username
         else:
-            self.host_string = parsed_url.hostname
-        # make sure remote_dir is always valid
+            username=getpass.getuser()
+
         if parsed_url.path:
-            # remove leading '/'
+            # remove first leading '/'
             self.remote_dir = re.sub(r'^/', r'', parsed_url.path, 1)
         else:
             self.remote_dir = '.'
-        self.remote_prefix = self.remote_dir + '/'
-        # maybe use different ssh port
-        if parsed_url.port:
-            globals.ssh_options = globals.ssh_options + " -oPort=%s" % parsed_url.port
-        # set some defaults if user has not specified already.
-        if "ServerAliveInterval" not in globals.ssh_options:
-            globals.ssh_options += " -oServerAliveInterval=%d" % ((int)(globals.timeout / 2))
-        if "ServerAliveCountMax" not in globals.ssh_options:
-            globals.ssh_options += " -oServerAliveCountMax=2"
+
+
         # set up password
         if globals.ssh_askpass:
-            self.password = self.get_password()
+            password = self.get_password()
         else:
             if parsed_url.password:
-                self.password = parsed_url.password
-                globals.ssh_askpass = True
+                password = parsed_url.password
             else:
-                self.password = ''
+                password = None
+        self.client = paramiko.SSHClient()
 
-    def run_scp_command(self, commandline):
-        """ Run an scp command, responding to password prompts """
-        for n in range(1, globals.num_retries+1):
-            if n > 1:
-                # sleep before retry
-                time.sleep(30)
-            log.Info("Running '%s' (attempt #%d)" % (commandline, n))
-            child = pexpect.spawn(commandline, timeout = None)
-            if globals.ssh_askpass:
-                state = "authorizing"
-            else:
-                state = "copying"
-            while 1:
-                if state == "authorizing":
-                    match = child.expect([pexpect.EOF,
-                                          "(?i)timeout, server not responding",
-                                          "(?i)pass(word|phrase .*):",
-                                          "(?i)permission denied",
-                                          "authenticity"])
-                    log.Debug("State = %s, Before = '%s'" % (state, child.before.strip()))
-                    if match == 0:
-                        log.Warn("Failed to authenticate")
-                        break
-                    elif match == 1:
-                        log.Warn("Timeout waiting to authenticate")
-                        break
-                    elif match == 2:
-                        child.sendline(self.password)
-                        state = "copying"
-                    elif match == 3:
-                        log.Warn("Invalid SSH password")
-                        break
-                    elif match == 4:
-                        log.Warn("Remote host authentication failed (missing known_hosts entry?)")
-                        break
-                elif state == "copying":
-                    match = child.expect([pexpect.EOF,
-                                          "(?i)timeout, server not responding",
-                                          "stalled",
-                                          "authenticity",
-                                          "ETA"])
-                    log.Debug("State = %s, Before = '%s'" % (state, child.before.strip()))
-                    if match == 0:
-                        break
-                    elif match == 1:
-                        log.Warn("Timeout waiting for response")
-                        break
-                    elif match == 2:
-                        state = "stalled"
-                    elif match == 3:
-                        log.Warn("Remote host authentication failed (missing known_hosts entry?)")
-                        break
-                elif state == "stalled":
-                    match = child.expect([pexpect.EOF,
-                                          "(?i)timeout, server not responding",
-                                          "ETA"])
-                    log.Debug("State = %s, Before = '%s'" % (state, child.before.strip()))
-                    if match == 0:
-                        break
-                    elif match == 1:
-                        log.Warn("Stalled for too long, aborted copy")
-                        break
-                    elif match == 2:
-                        state = "copying"
-            child.close(force = True)
-            if child.exitstatus == 0:
-                return
-            log.Warn("Running '%s' failed (attempt #%d)" % (commandline, n))
-        log.Warn("Giving up trying to execute '%s' after %d attempts" % (commandline, globals.num_retries))
-        raise BackendException("Error running '%s'" % commandline)
+        # paramiko uses logging with the normal python severity levels,
+        # but duplicity uses both custom levels and inverted logic...*sigh*
+        self.client.set_log_channel("sshbackend")
+        ours=paramiko.util.get_logger("sshbackend")
+        dest=logging.StreamHandler(sys.stderr)
+        dest.setFormatter(logging.Formatter('ssh: %(message)s'))
+        ours.addHandler(dest)
 
-    def run_sftp_command(self, commandline, commands):
-        """ Run an sftp command, responding to password prompts, passing commands from list """
-        maxread = 2000 # expected read buffer size
-        responses = [pexpect.EOF,
-                     "(?i)timeout, server not responding",
-                     "sftp>",
-                     "(?i)pass(word|phrase .*):",
-                     "(?i)permission denied",
-                     "authenticity",
-                     "(?i)no such file or directory",
-                     "Couldn't delete file: No such file or directory",
-                     "Couldn't delete file",
-                     "open(.*): Failure"]
-        max_response_len = max([len(p) for p in responses[1:]])
-        for n in range(1, globals.num_retries+1):
-            if n > 1:
-                # sleep before retry
-                time.sleep(30)
-            log.Info("Running '%s' (attempt #%d)" % (commandline, n))
-            child = pexpect.spawn(commandline, timeout = None, maxread=maxread)
-            cmdloc = 0
-            while 1:
-                match = child.expect(responses,
-                                     searchwindowsize=maxread+max_response_len)
-                log.Debug("State = sftp, Before = '%s'" % (child.before.strip()))
-                if match == 0:
-                    break
-                elif match == 1:
-                    log.Info("Timeout waiting for response")
-                    break
-                if match == 2:
-                    if cmdloc < len(commands):
-                        command = commands[cmdloc]
-                        log.Info("sftp command: '%s'" % (command,))
-                        child.sendline(command)
-                        cmdloc += 1
-                    else:
-                        command = 'quit'
-                        child.sendline(command)
-                        res = child.before
-                elif match == 3:
-                    child.sendline(self.password)
-                elif match == 4:
-                    if not child.before.strip().startswith("mkdir"):
-                        log.Warn("Invalid SSH password")
-                        break
-                elif match == 5:
-                    log.Warn("Host key authenticity could not be verified (missing known_hosts entry?)")
-                    break
-                elif match == 6:
-                    if not child.before.strip().startswith("rm"):
-                        log.Warn("Remote file or directory does not exist in command='%s'" % (commandline,))
-                        break
-                elif match == 7:
-                    if not child.before.strip().startswith("Removing"):
-                        log.Warn("Could not delete file in command='%s'" % (commandline,))
-                        break;
-                elif match == 8:
-                    log.Warn("Could not delete file in command='%s'" % (commandline,))
-                    break
-                elif match == 9:
-                    log.Warn("Could not open file in command='%s'" % (commandline,))
-                    break
-            child.close(force = True)
-            if child.exitstatus == 0:
-                return res
-            log.Warn("Running '%s' failed (attempt #%d)" % (commandline, n))
-        log.Warn("Giving up trying to execute '%s' after %d attempts" % (commandline, globals.num_retries))
-        raise BackendException("Error running '%s'" % commandline)
+        # ..and the duplicity levels are neither linear, 
+        # nor are the names compatible with python logging, eg. 'NOTICE'...WAAAAAH!
+        plevel=logging.getLogger("duplicity").getEffectiveLevel()
+        if plevel <= 1:
+            wanted=logging.DEBUG
+        elif plevel <= 5:
+            wanted=logging.INFO
+        elif plevel <= 7:
+            wanted=logging.WARNING
+        elif plevel <= 9:
+            wanted=logging.ERROR
+        else:
+            wanted=logging.CRITICAL
+        ours.setLevel(wanted)
+        
+        # load known_hosts files
+        # paramiko is very picky wrt format and bails out on any problem...
+        try:
+            if os.path.isfile("/etc/ssh/ssh_known_hosts"):
+                self.client.load_system_host_keys("/etc/ssh/ssh_known_hosts")
+        except Exception, e:
+            raise BackendException("could not load /etc/ssh/ssh_known_hosts, maybe corrupt?")
+        try:
+            self.client.load_system_host_keys()
+        except Exception, e:
+            raise BackendException("could not load ~/.ssh/known_hosts, maybe corrupt?")
+    
+        # alternative ssh private key?
+        keyfilename=None
+        m=re.search("-oidentityfile=(\S+)",globals.ssh_options,re.I)
+        if (m!=None):
+            keyfilename=m.group(1)
 
-    def put(self, source_path, remote_filename = None):
-        if globals.use_scp:
-            self.put_scp(source_path, remote_filename = remote_filename)
+        portnumber=(parsed_url.port if parsed_url.port else 22)
+        try:
+            self.client.connect(hostname=parsed_url.hostname, port=portnumber,
+                                username=username, password=password,
+                                allow_agent=True, look_for_keys=True,
+                                key_filename=keyfilename) 
+        except Exception, e:
+            raise BackendException("ssh connection to %s:%d failed: %s" % (parsed_url.hostname,portnumber,e))
+        self.client.get_transport().set_keepalive((int)(globals.timeout / 2))
+
+        # scp or sftp?
+        if (globals.use_scp):
+            # sanity-check the directory name
+            if (re.search("'",self.remote_dir)):
+                raise BackendException("cannot handle directory names with single quotes with --use-scp!")
+
+            # make directory if needed
+            self.runremote("test -d '%s' || mkdir -p '%s'" % (self.remote_dir,self.remote_dir),False,"scp mkdir ")
         else:
-            self.put_sftp(source_path, remote_filename = remote_filename)
+            try:
+                self.sftp=self.client.open_sftp()
+            except Exception, e:
+                raise BackendException("sftp negotiation failed: %s" % e)
 
-    def put_sftp(self, source_path, remote_filename = None):
-        """Use sftp to copy source_dir/filename to remote computer"""
-        if not remote_filename:
-            remote_filename = source_path.get_filename()
-        commands = ["put \"%s\" \"%s.%s.part\"" %
-                    (source_path.name, self.remote_prefix, remote_filename),
-                    "rename \"%s.%s.part\" \"%s%s\"" %
-                    (self.remote_prefix, remote_filename,self.remote_prefix, remote_filename)]
-        commandline = ("%s %s %s" % (globals.sftp_command,
-                                     globals.ssh_options,
-                                     self.host_string))
-        self.run_sftp_command(commandline, commands)
 
-    def put_scp(self, source_path, remote_filename = None):
-        """Use scp to copy source_dir/filename to remote computer"""
+            # move to the appropriate directory, possibly after creating it and its parents 
+            dirs = self.remote_dir.split(os.sep)
+            if len(dirs) > 0:
+                if not dirs[0]:
+                    dirs = dirs[1:]
+                    dirs[0]= '/' + dirs[0]
+                for d in dirs:
+                    if (d == ''):
+                        continue
+                    try: 
+                        attrs=self.sftp.stat(d)
+                    except IOError, e:
+                        if e.errno == errno.ENOENT:
+                            try:
+                                self.sftp.mkdir(d)
+                            except Exception, e:
+                                raise BackendException("sftp mkdir %s failed: %s" % (self.sftp.normalize(".")+"/"+d,e))
+                        else:
+                            raise BackendException("sftp stat %s failed: %s" % (self.sftp.normalize(".")+"/"+d,e))
+                    try:
+                        self.sftp.chdir(d)
+                    except Exception, e:
+                        raise BackendException("sftp chdir to %s failed: %s" % (self.sftp.normalize(".")+"/"+d,e))
+
+    def put(self, source_path, remote_filename = None):
+        """transfers a single file to the remote side.
+        In scp mode unavoidable quoting issues will make this fail if the remote directory or file name 
+        contain single quotes."""
         if not remote_filename:
             remote_filename = source_path.get_filename()
-        commandline = "%s %s %s %s:%s%s" % \
-            (globals.scp_command, globals.ssh_options, source_path.name, self.host_string,
-             self.remote_prefix, remote_filename)
-        self.run_scp_command(commandline)
+        if (globals.use_scp):
+            f=file(source_path.name,'rb')
+            try:
+                chan=self.client.get_transport().open_session()
+                chan.settimeout(globals.timeout)
+                chan.exec_command("scp -t '%s'" % self.remote_dir) # scp in sink mode uses the arg as base directory
+            except Exception, e:
+                raise BackendException("scp execution failed: %s" % e)
+            # scp protocol: one 0x0 after startup, one after the Create meta, one after saving
+            # if there's a problem: 0x1 or 0x02 and some error text
+            response=chan.recv(1) 
+            if (response!="\0"):
+                raise BackendException("scp remote error: %s" % chan.recv(-1))
+            fstat=os.stat(source_path.name)
+            chan.send('C%s %d %s\n' %(oct(fstat.st_mode)[-4:], fstat.st_size, remote_filename))
+            response=chan.recv(1)
+            if (response!="\0"):
+                raise BackendException("scp remote error: %s" % chan.recv(-1))
+            chan.sendall(f.read()+'\0')
+            f.close()
+            response=chan.recv(1)
+            if (response!="\0"):
+                raise BackendException("scp remote error: %s" % chan.recv(-1))
+            chan.close()
+        else:
+            try: 
+                self.sftp.put(source_path.name,remote_filename)
+            except Exception, e:
+                raise BackendException("sftp put of %s (as %s) failed: %s" % (source_path.name,remote_filename,e))
+
 
     def get(self, remote_filename, local_path):
-        if globals.use_scp:
-            self.get_scp(remote_filename, local_path)
-        else:
-            self.get_sftp(remote_filename, local_path)
+        """retrieves a single file from the remote side.
+        In scp mode unavoidable quoting issues will make this fail if the remote directory or file names 
+        contain single quotes."""
+        if (globals.use_scp):
+            try:
+                chan=self.client.get_transport().open_session()
+                chan.settimeout(globals.timeout)
+                chan.exec_command("scp -f '%s/%s'" % (self.remote_dir,remote_filename))
+            except Exception, e:
+                raise BackendException("scp execution failed: %s" % e)
 
-    def get_sftp(self, remote_filename, local_path):
-        """Use sftp to get a remote file"""
-        commands = ["get \"%s%s\" \"%s\"" %
-                    (self.remote_prefix, remote_filename, local_path.name)]
-        commandline = ("%s %s %s" % (globals.sftp_command,
-                                     globals.ssh_options,
-                                     self.host_string))
-        self.run_sftp_command(commandline, commands)
-        local_path.setdata()
-        if not local_path.exists():
-            raise BackendException("File %s not found locally after get "
-                                   "from backend" % local_path.name)
+            chan.send('\0')     # overall ready indicator
+            msg=chan.recv(-1)
+            m=re.match(r"C([0-7]{4})\s+(\d+)\s+(\S.*)$",msg)
+            if (m==None or m.group(3)!=remote_filename):
+                raise BackendException("scp get %s failed: incorrect response '%s'" % (remote_filename,msg))
+            chan.recv(1)        # dispose of the newline trailing the C message
 
-    def get_scp(self, remote_filename, local_path):
-        """Use scp to get a remote file"""
-        commandline = "%s %s %s:%s%s %s" % \
-            (globals.scp_command, globals.ssh_options, self.host_string, self.remote_prefix,
-             remote_filename, local_path.name)
-        self.run_scp_command(commandline)
+            size=int(m.group(2))
+            togo=size
+            f=file(local_path.name,'wb')
+            chan.send('\0')     # ready for data
+            try:
+                while togo>0:
+                    buff=chan.recv(read_blocksize if (togo>read_blocksize) else togo)
+                    f.write(buff)
+                    togo-=len(buff)
+            except Exception, e:
+                raise BackendException("scp get %s failed: %s" % (remote_filename,e))
+            
+            msg=chan.recv(1)    # check the final status 
+            if msg!='\0':
+                raise BackendException("scp get %s failed: %s" % (remote_filename,chan.recv(-1)))
+            f.close()
+            chan.send('\0')     # send final done indicator
+            chan.close()
+        else:
+            try:
+                self.sftp.get(remote_filename,local_path.name)
+            except Exception, e:
+                raise BackendException("sftp get of %s (to %s) failed: %s" % (remote_filename,local_path.name,e))
         local_path.setdata()
-        if not local_path.exists():
-            raise BackendException("File %s not found locally after get "
-                                   "from backend" % local_path.name)
 
     def list(self):
-        """
-        List files available for scp
-
-        Note that this command can get confused when dealing with
-        files with newlines in them, as the embedded newlines cannot
-        be distinguished from the file boundaries.
-        """
-        dirs = self.remote_dir.split(os.sep)
-        if len(dirs) > 0:
-            if not dirs[0] :
-                dirs = dirs[1:]
-                dirs[0]= '/' + dirs[0]
-        mkdir_commands = [];
-        for d in dirs:
-            mkdir_commands += ["mkdir \"%s\"" % (d)] + ["cd \"%s\"" % (d)]
-
-        commands = mkdir_commands + ["ls -1"]
-        commandline = ("%s %s %s" % (globals.sftp_command,
-                                     globals.ssh_options,
-                                     self.host_string))
-
-        l = self.run_sftp_command(commandline, commands).split('\n')[1:]
-
-        return filter(lambda x: x, map(string.strip, l))
+        """lists the contents of the one-and-only duplicity dir on the remote side.
+        In scp mode unavoidable quoting issues will make this fail if the directory name 
+        contains single quotes."""
+        if (globals.use_scp):
+            output=self.runremote("ls -1 '%s'" % self.remote_dir,False,"scp dir listing ")
+            return output.splitlines()
+        else:
+            try:
+                return self.sftp.listdir()
+            except Exception, e:
+                raise BackendException("sftp listing of %s failed: %s" % (self.sftp.getcwd(),e))
 
     def delete(self, filename_list):
-        """
-        Runs sftp rm to delete files.  Files must not require quoting.
-        """
-        commands = ["cd \"%s\"" % (self.remote_dir,)]
+        """deletes all files in the list on the remote side. In scp mode unavoidable quoting issues 
+        will cause failures if filenames containing single quotes are encountered."""
         for fn in filename_list:
-            commands.append("rm \"%s\"" % fn)
-        commandline = ("%s %s %s" % (globals.sftp_command, globals.ssh_options, self.host_string))
-        self.run_sftp_command(commandline, commands)
+            if (globals.use_scp):
+                self.runremote("rm '%s/%s'" % (self.remote_dir,fn),False,"scp rm ")
+            else:
+                try:
+                    self.sftp.remove(fn)
+                except Exception, e:
+                    raise BackendException("sftp rm %s failed: %s" % (fn,e))
 
-duplicity.backend.register_backend("ssh", SSHBackend)
-duplicity.backend.register_backend("scp", SSHBackend)
-duplicity.backend.register_backend("sftp", SSHBackend)
+    def runremote(self,cmd,ignoreexitcode=False,errorprefix=""):
+        """small convenience function that opens a shell channel, runs remote command and returns 
+        stdout of command. throws an exception if exit code!=0 and not ignored"""
+        try:
+            chan=self.client.get_transport().open_session()
+            chan.settimeout(globals.timeout)
+            chan.exec_command(cmd)
+        except Exception, e:
+            raise BackendException("%sexecution failed: %s" % (errorprefix,e))
+        output=chan.recv(-1)
+        res=chan.recv_exit_status()
+        if (res!=0 and not ignoreexitcode):
+            raise BackendException("%sfailed(%d): %s" % (errorprefix,res,chan.recv_stderr(4096)))
+        return output
+
+duplicity.backend.register_backend("sftp", SftpBackend)
+duplicity.backend.register_backend("scp", SftpBackend)
+duplicity.backend.register_backend("ssh", SftpBackend)
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' duplicity-0.6.17~/duplicity/commandline.py duplicity-0.6.17/duplicity/commandline.py
--- duplicity-0.6.17~/duplicity/commandline.py	2012-02-14 15:25:47.000000000 +1000
+++ duplicity-0.6.17/duplicity/commandline.py	2012-02-14 15:25:47.869271261 +1000
@@ -68,6 +68,9 @@
                           "and will be removed in a future release.\n"
                           "Use of default filenames is strongly suggested.") % opt
 
+def scp_deprecation(o,s,v,p):
+    print >>sys.stderr, "Warning: Option %s is deprecated and ignored. Use --ssh-options instead." % o
+
 
 def expand_fn(filename):
     return os.path.expanduser(os.path.expandvars(filename))
@@ -466,11 +469,13 @@
 
     # scp command to use
     # TRANSL: noun
-    parser.add_option("--scp-command", metavar=_("command"))
+    parser.add_option("--scp-command", nargs=1, type="string",
+                      action="callback", callback=scp_deprecation)
 
     # sftp command to use
     # TRANSL: noun
-    parser.add_option("--sftp-command", metavar=_("command"))
+    parser.add_option("--sftp-command", nargs=1, type="string",
+                      action="callback", callback=scp_deprecation)
 
     # If set, use short (< 30 char) filenames for all the remote files.
     parser.add_option("--short-filenames", action="callback",
