#! /bin/sh /usr/share/dpatch/dpatch-run
## 03forcecleanup.dpatch by  <az@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: fix for #572792: we force a extra-clean cleanup for all remove* ops

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' duplicity-0.6.14~/duplicity.1 duplicity-0.6.14/duplicity.1
--- duplicity-0.6.14~/duplicity.1	2011-07-25 18:59:04.000000000 +1000
+++ duplicity-0.6.14/duplicity.1	2011-07-25 19:01:30.205691745 +1000
@@ -182,6 +182,14 @@
 limit the amount of old outdated material that otherwise accumulates 
 in the archive dir.
 
+.B Note: 
+the Debian version of duplicity automatically runs a 
+cleanup --extra-clean whenever old backup sets are removed (i.e. if one
+of the remove commands is run with the --force option present and 
+if something removable is found). This is to 
+limit the amount of old outdated material that otherwise accumulates 
+in the archive dir.
+
 .TP
 .BI "remove-older-than " time
 Delete all backup sets older than the given time.  Old backup sets
@@ -229,6 +237,9 @@
 
 .SH OPTIONS
 
+The note regarding automatic cleanups above
+also applies to remove-all-but-n-full.
+
 .TP
 .BI --allow-source-mismatch
 Do not abort on attempts to use the same archive dir or remote backend
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' duplicity-0.6.14~/src/collections.py duplicity-0.6.14/src/collections.py
--- duplicity-0.6.14~/src/collections.py	2011-07-25 19:01:30.160688142 +1000
+++ duplicity-0.6.14/src/collections.py	2011-07-25 19:02:01.681211438 +1000
@@ -989,8 +989,6 @@
             if self.matched_chain_pair:
                 matched_sig_chain = self.matched_chain_pair[0]
                 for sig_chain in self.all_sig_chains:
-                    print sig_chain.start_time, matched_sig_chain.start_time,
-                    print sig_chain.end_time, matched_sig_chain.end_time
                     if (sig_chain.start_time == matched_sig_chain.start_time and
                         sig_chain.end_time == matched_sig_chain.end_time):
                         old_sig_chains.remove(sig_chain)
